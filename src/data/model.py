# -*- coding: utf-8 -*-
"""
GeomMop configuration file data structure

Data structure of configuration files forms a tree. Each node has
access to its descendats, so only the reference to the root node is
needed to access all the nodes in the tree.

Original data consist of records, arrays and scalar values. A node is
constructed for each scalar, item in array and key in record. Each node
has a path that indicates its position in the tree.

@author: Tomas Krizek
"""


def _circular_check(function):
    """Runtime exception handler for circular references."""
    def inner(*args, **kwargs):
        try:
            return function(*args, **kwargs)
        except RuntimeError:
            raise RefError("Circular reference detected!")
    return inner


class DataNode:
    """
    Represents a node in the tree structure.

    The complete tree is represented by its root node.
    """

    def __init__(self, data, parent=None, name=''):
        """
        Recursively constructs the tree structure from data.

        parent and name parameters are to be ommitted for the root node.
        """
        self._ref = self
        self.parent = parent
        self.name = name
        self._initialize_value(data)

    @property
    @_circular_check
    def value(self):
        """
        Returns the contents of a node.

        Can be a primitve data type, a list or a dict,
        representing scalar, array or record respectively.

        If this node refers to another, its value is returned instead.
        """
        ref = self._ref
        if ref == ref._ref:
            # reference points to itself -> end-point value
            return ref._value
        else:
            # multi-level reference, resolve recursively
            return ref.value

    @value.setter
    @_circular_check
    def value(self, value):
        """Setter for value. Resolves references."""
        ref = self._ref
        if ref == ref._ref:
            # reference points to itself -> end-point value
            ref._value = value
        else:
            # multi-level reference, resolve recursively
            ref.value = value

    @property
    def ref(self):
        """Returns either the reference (if set) of self."""
        if self._ref == self:
            return None
        return self._ref

    @ref.setter
    def ref(self, value):
        """Sets the reference of this node to another."""
        if value is None:
            value = self
        self._ref = value

    @property
    def path(self):
        """
        Returns a path to this node. Path is generated by traversing the
        tree up to the root node. An item in path can eithery be an index
        or a key, representing array or a record, respectively.

        TODO issue with references:
            if this is a reference, the original path is returned instead of
            the actual path
        """
        try:
            path = self.parent.path
        except AttributeError:
            path = ''
        if not path.endswith('/'):  # ensure only single slash
            path = path + '/'
        return path + self.name

    def _initialize_value(self, data):
        """Ensures the creation of child nodes for dicts and lists."""
        # TODO split value and children
        if isinstance(data, dict):
            self.value = {}
            for key, value in data.items():
                self.value[key] = self._create_child_node(value, key)
        elif isinstance(data, list):
            self.value = []
            for i, item in enumerate(data):
                self.value.append(self._create_child_node(item, str(i)))
        else:
            self.value = data

    def _create_child_node(self, data, name):
        """
        Creates a child DataNode instance. If provided data is already
        a DataNode, it will use the existing instance and change its
        position in the tree by manipulating parent and name.
        """
        if isinstance(data, DataNode):
            data.parent = self
            data.name = name
            return data
        else:
            return DataNode(data, self, name)

    def get(self, path):
        """
        Returns node at specified path. Supports both relative and
        absolute paths.
        """
        if path.startswith(self.path):  # absolute path
            path = path[len(self.path):]
        elif path.startswith('/'):  # absolute path with different location
            raise LookupError("Can't resolve {path} from node {location}".format(path=path, location=self.path))
        node = self
        for key in path.split('/'):
            if not key or key == '.':
                continue
            elif key == '..':
                node = node.parent
                continue
            try:
                key = int(key)
            except ValueError:
                pass
            try:
                node = node.value[key]
            except LookupError:
                raise LookupError("Node {key} does not exist in {location}".format(key=key, location=node.path))
        return node

    def __repr__(self):
        ref_text = ' (ref {reference})'.format(reference=self._ref) if self._ref != self else ''
        return 'DataNode({location}{ref_text})'.format(location=self.path, ref_text=ref_text)


class RefError(Exception):
    """Exception represents invalid references in configuration file."""
    def __init__(self, message):
        super(RefError, self).__init__(message)

